package org.avda.testtask.service.arithmetic;

import java.io.*;


/**
 * Decompression application using static arithmetic coding.
 * <p>Usage: java ArithmeticDecompress InputFile OutputFile</p>
 * <p>This decompresses files generated by the "ArithmeticCompress" application.</p>
 */
public class ArithmeticDecompress {

    public static byte[] run(String inFilePath, String outFilePath) throws IOException {

        File inputFile  = new File(inFilePath);
        File outputFile = new File(outFilePath);

        byte[] crcBytes = new byte[8];
        int bytesRead = 0;
        OutputStream out = null;
        InputStream inStream = null;
        BitInputStream in = null;

        try{
            inStream = new FileInputStream(inputFile);
            bytesRead = inStream.read(crcBytes, 0, 8); // read first 8 bytes - CRC
            if(bytesRead != 8) throw new IOException("Crc citanje prvih 8 byta invalid");

            // Perform file decompression
            out = new BufferedOutputStream(new FileOutputStream(outputFile));
            in = new BitInputStream(new BufferedInputStream(inStream));
            FrequencyTable freqs = readFrequencies(in);
            decompress(freqs, in, out);
        }
        catch (IOException e){
            System.err.println("Greska u dekompresiji");
        }
        finally{
            if(in != null){
                in.close();
            }
            if(out != null){
                out.close();
            }
        }

        return crcBytes;
    }



    private static FrequencyTable readFrequencies(BitInputStream in) throws IOException {
        int[] freqs = new int[257];
        for (int i = 0; i < 256; i++)
            freqs[i] = readInt(in, 32);
        freqs[256] = 1;  // EOF symbol
        return new SimpleFrequencyTable(freqs);
    }



    private static void decompress(FrequencyTable freqs, BitInputStream in, OutputStream out) throws IOException {
        ArithmeticDecoder dec = new ArithmeticDecoder(32, in);
        while (true) {
            int symbol = dec.read(freqs);
            if (symbol == 256)  // EOF symbol
                break;
            out.write(symbol);
        }
    }


    // Reads an unsigned integer of the given bit width from the given stream.
    private static int readInt(BitInputStream in, int numBits) throws IOException {
        if (numBits < 0 || numBits > 32)
            throw new IllegalArgumentException();

        int result = 0;
        for (int i = 0; i < numBits; i++)
            result = (result << 1) | in.readNoEof();  // Big endian
        return result;
    }

}